
//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.239
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

// 
// 此源代码由 wsdl 自动生成, Version=4.0.30319.1。
// 
namespace ETMS.UnCompress
{
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name = "UnCompressSoap", Namespace = "http://tempuri.org/")]
    public partial class UnCompress : System.Web.Services.Protocols.SoapHttpClientProtocol
    {

        private System.Threading.SendOrPostCallback UnRAROperationCompleted;

        private System.Threading.SendOrPostCallback MoveFileOperationCompleted;

        private System.Threading.SendOrPostCallback WaitExecuteForExitOperationCompleted;

        /// <remarks/>
        public UnCompress()
        {
            this.Url = System.Configuration.ConfigurationManager.AppSettings["UnPressUrl"];
        }

        /// <remarks/>
        public event UnRARCompletedEventHandler UnRARCompleted;

        /// <remarks/>
        public event MoveFileCompletedEventHandler MoveFileCompleted;

        /// <remarks/>
        public event WaitExecuteForExitCompletedEventHandler WaitExecuteForExitCompleted;

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/UnRAR", RequestNamespace = "http://tempuri.org/", ResponseNamespace = "http://tempuri.org/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool UnRAR(string path, string rarPath, string rarName)
        {
            object[] results = this.Invoke("UnRAR", new object[] {
                        path,
                        rarPath,
                        rarName});
            return ((bool)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginUnRAR(string path, string rarPath, string rarName, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UnRAR", new object[] {
                        path,
                        rarPath,
                        rarName}, callback, asyncState);
        }

        /// <remarks/>
        public bool EndUnRAR(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((bool)(results[0]));
        }

        /// <remarks/>
        public void UnRARAsync(string path, string rarPath, string rarName)
        {
            this.UnRARAsync(path, rarPath, rarName, null);
        }

        /// <remarks/>
        public void UnRARAsync(string path, string rarPath, string rarName, object userState)
        {
            if ((this.UnRAROperationCompleted == null))
            {
                this.UnRAROperationCompleted = new System.Threading.SendOrPostCallback(this.OnUnRAROperationCompleted);
            }
            this.InvokeAsync("UnRAR", new object[] {
                        path,
                        rarPath,
                        rarName}, this.UnRAROperationCompleted, userState);
        }

        private void OnUnRAROperationCompleted(object arg)
        {
            if ((this.UnRARCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UnRARCompleted(this, new UnRARCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/MoveFile", RequestNamespace = "http://tempuri.org/", ResponseNamespace = "http://tempuri.org/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void MoveFile(string sourceFile, string desFile)
        {
            this.Invoke("MoveFile", new object[] {
                        sourceFile,
                        desFile});
        }

        /// <remarks/>
        public System.IAsyncResult BeginMoveFile(string sourceFile, string desFile, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("MoveFile", new object[] {
                        sourceFile,
                        desFile}, callback, asyncState);
        }

        /// <remarks/>
        public void EndMoveFile(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        public void MoveFileAsync(string sourceFile, string desFile)
        {
            this.MoveFileAsync(sourceFile, desFile, null);
        }

        /// <remarks/>
        public void MoveFileAsync(string sourceFile, string desFile, object userState)
        {
            if ((this.MoveFileOperationCompleted == null))
            {
                this.MoveFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnMoveFileOperationCompleted);
            }
            this.InvokeAsync("MoveFile", new object[] {
                        sourceFile,
                        desFile}, this.MoveFileOperationCompleted, userState);
        }

        private void OnMoveFileOperationCompleted(object arg)
        {
            if ((this.MoveFileCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.MoveFileCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/WaitExecuteForExit", RequestNamespace = "http://tempuri.org/", ResponseNamespace = "http://tempuri.org/", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string WaitExecuteForExit(string sourcePath, string targetPath, int waitTime, bool poly2bitmap)
        {
            object[] results = this.Invoke("WaitExecuteForExit", new object[] {
                        sourcePath,
                        targetPath,
                        waitTime,
                        poly2bitmap});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginWaitExecuteForExit(string sourcePath, string targetPath, int waitTime, bool poly2bitmap, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("WaitExecuteForExit", new object[] {
                        sourcePath,
                        targetPath,
                        waitTime,
                        poly2bitmap}, callback, asyncState);
        }

        /// <remarks/>
        public string EndWaitExecuteForExit(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        public void WaitExecuteForExitAsync(string sourcePath, string targetPath, int waitTime, bool poly2bitmap)
        {
            this.WaitExecuteForExitAsync(sourcePath, targetPath, waitTime, poly2bitmap, null);
        }

        /// <remarks/>
        public void WaitExecuteForExitAsync(string sourcePath, string targetPath, int waitTime, bool poly2bitmap, object userState)
        {
            if ((this.WaitExecuteForExitOperationCompleted == null))
            {
                this.WaitExecuteForExitOperationCompleted = new System.Threading.SendOrPostCallback(this.OnWaitExecuteForExitOperationCompleted);
            }
            this.InvokeAsync("WaitExecuteForExit", new object[] {
                        sourcePath,
                        targetPath,
                        waitTime,
                        poly2bitmap}, this.WaitExecuteForExitOperationCompleted, userState);
        }

        private void OnWaitExecuteForExitOperationCompleted(object arg)
        {
            if ((this.WaitExecuteForExitCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.WaitExecuteForExitCompleted(this, new WaitExecuteForExitCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        public new void CancelAsync(object userState)
        {
            base.CancelAsync(userState);
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
    public delegate void UnRARCompletedEventHandler(object sender, UnRARCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UnRARCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal UnRARCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public bool Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
    public delegate void MoveFileCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
    public delegate void WaitExecuteForExitCompletedEventHandler(object sender, WaitExecuteForExitCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "4.0.30319.1")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class WaitExecuteForExitCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal WaitExecuteForExitCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string Result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}

